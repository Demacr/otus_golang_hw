package main

var templateFile = `// Code generated by cool go-validate tool; DO NOT EDIT.
package {{ .Package }}

import (
    "errors"
    "fmt"
    "regexp"
)

type ValidationError struct {
    Field string
    Err   error
}

{{ range .ValidatedStructs }}
func (st {{ .Name }}) Validate() ([]ValidationError, error) {
    fmt.Sprintf("Dummy")
    validationErrors := make([]ValidationError, 0)
    {{- range .Fields }}
        {{- if eq .Type "int" }}
            {{- if .IsMin }}
    if st.{{ .Name }} < {{ .MinValue }} {
        validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New("{{ .Name }} is less than min value {{ .MinValue }}")})
    }
            {{- end }}
            {{- if .IsMax }}
    if st.{{ .Name }} > {{ .MaxValue }} {
        validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New("{{ .Name }} is more than max value {{ .MaxValue }}")})
    }
            {{- end }}
            {{- if .IsIn }}
    switch st.{{ .Name }} {
    case 
        {{ range $i, $e := .In }}
        {{- if $i }},
        {{ end }}{{ $e }}
        {{- end }}:
    default:
        validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New("{{ .Name }} is out of IN slice")})
    }
            {{- end }}
        {{- else if eq .Type "[]int" }}
    for index, value := range st.{{ .Name }} {
            {{- if .IsMin }}
        if value < {{ .MinValue }} {
            validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New(fmt.Sprintf("{{ .Name }}[%v] is less than min value {{ .MinValue }}", index))})
        }
            {{- end }}
            {{- if .IsMax }}
        if value > {{ .MaxValue }} {
            validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New(fmt.Sprintf("{{ .Name }}[%v] is more than max value {{ .MaxValue }}", index))})
        }
            {{- end }}
            {{- if .IsIn }}
        switch value {
        case 
        {{ range $i, $e := .In }}
        {{- if $i }},
        {{ end }}{{ $e }}
        {{- end }}:
        default:
            validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New(fmt.Sprintf("{{ .Name }}[%v] is out of IN slice", index))})
        }
    }
            {{- end }}
        {{- else if eq .Type "string" }}
            {{- if .IsLen }}
    if len(st.{{ .Name }}) != {{ .Len }} {
        validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New("{{ .Name }}'s length is not equal {{ .Len }}")})
    }
            {{- end }}            
            {{- if .IsIn }}
    switch st.{{ .Name }} {
    case
        {{ range $i, $e := .InString }}
        {{- if $i }},
        {{ end }}"{{ $e }}"
        {{- end }}:
    default:
        validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New("{{ .Name }} is out of IN slice")})
    }
            {{- end }}
            {{- if .IsRE }}
    matched, err := regexp.MatchString("{{ .RE }}", st.{{ .Name }})
    if err != nil {
        return nil, err
    }

    if !matched {
        validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New("{{ .Name }} is not matched regexp")})
    }
            {{- end }}
        {{- else if eq .Type "[]string" }}
    for index, value := range st.{{ .Name }} {
            {{- if .IsLen }}
        if len(value) != {{ .Len }} {
            validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New(fmt.Sprintf("{{ .Name }}[%v]'s length is not equal {{ .Len }}", index))})
        }
            {{- end }}            
            {{- if .IsIn }}
        switch value {
        case
            {{ range $i, $e := .InString }}
            {{- if $i }},
            {{ end }}"{{ $e }}"
            {{- end }}:
        default:
            validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New(fmt.Sprintf("{{ .Name }}[%v] is out of IN slice", index))})
        }
            {{- end }}
            {{- if .IsRE }}
        matched, err := regexp.MatchString("{{ .RE }}", value)
        if err != nil {
            return nil, err
        }
    
        if !matched {
            validationErrors = append(validationErrors, ValidationError{"{{ .Name }}", errors.New(fmt.Sprintf("{{ .Name }}[%v] is not matched regexp", index))})
        }
            {{- end }}
    }
        {{- end }}
    {{- end }}

    return validationErrors, nil
}
{{ end }}`
